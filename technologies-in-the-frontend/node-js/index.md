# Node JS

Информация взята отсюда: <https://www.freecodecamp.org/news/the-definitive-node-js-handbook-6912378afc6e> <br>
Перевод в формате пдф можно взять отсюда: <https://habr.com/ru/company/ruvds/blog/428576/>

## Менеджер версий

Популярным менеджером версий Node.js является [nvm](https://github.com/nvm-sh/nvm/blob/master/README.md).
Это средство позволяет удобно переключаться
между различными версиями Node.js, с его помощью можно, например, установить и попробовать
новую версию Node.js, после чего, при необходимости, вернуться на старую. Nvm пригодится и в
ситуации, когда нужно испытать какой-нибудь код на старой версии Node.js.

---

## Программные способы выхода из приложения

1. Модуль ядра process предоставляет удобный метод, который позволяет осуществить программный
   выход из Node.js-приложения. Выглядит это так:

   ```js
   process.exit(1);
   ```

   Когда Node.js встречает в коде такую команду, это приводит к тому, что его процесс мгновенно
   завершается. Это означает, что абсолютно всё, чем занималась программа, будет довольно грубо и
   безусловно прервано. Речь идёт о невызванных коллбэках, о выполняемых в момент выхода сетевых
   запросах, о действиях с файлами, об операциях записи в stdout или stderr.

   По умолчанию этот код имеет значение 0, что означает успешное завершение работы. Другие коды
   выхода имеют другие значения, которые могут оказаться полезными для использования их в
   собственной системе для того, чтобы наладить взаимодействие одних программ с другими.
   Подробности о кодах завершения работы программ можно почитать [здесь](https://nodejs.org/api/process.html#process_exit_codes).

   Код выхода, кроме того, можно назначить свойству process.exitCode. Выглядит это так:

   ```js
   process.exitCode = 1;
   ```

   После того, как программа завершит работу, Node.js вернёт системе этот код.

2. Для завершения работы программ преимущественно нужно использовать сигнал SIGTERM и выполнить
   необходимые действия с помощью соответствующего обработчика. Сигналы — это средства взаимодействия процессов в стандарте.
   Они представляют собой уведомления, отправляемые процессу для того, чтобы сообщить ему о неких событиях. Пример:

   ```js
   const express = require("express");
   const app = express();

   app.get("/", (req, res) => {
     res.send("Hi!");
   });
   app.listen(3000, () => console.log("Server ready"));

   process.on("SIGTERM", () => {
     app.close(() => {
       console.log("Process terminated");
     });
   });
   ```

   Например, сигнал SIGKILL сообщает процессу о том, что ему нужно немедленно завершить работу.
   Он, в идеале, работает так же, как process.exit(). Сигнал SIGTERM сообщает процессу о том, что ему нужно
   осуществить процедуру нормального
   завершения работы. Подобные сигналы отправляются из менеджеров процессов, вроде upstart или
   supervisord, и из многих других.
   Отправить такой сигнал можно и из самой программы, воспользовавшись следующей командой:

   ```js
   process.kill(process.pid, "SIGTERM");
   ```

---

## Чтение переменных окружения

Вот пример работы с переменной окружения NODE_ENV, которая, по умолчанию, установлена в
значение development:

```js
process.env.NODE_ENV; // "development"
```

Если, до запуска скрипта, установить её в значение production, это сообщит Node.js о том, что
программа выполняется в продакшн-окружении. Подобным образом можно работать и с другими переменными среды,
например, с теми, которые установлены вами самостоятельно.

## Режим REPL

Аббревиатура REPL расшифровывается как Read-Evaluate-Print-Loop (цикл «чтение — вычисление —
вывод»). Использование REPL — это отличный способ быстрого исследования возможностей Node.js.

Если команду `node`, но не указывать имя файла, Node.js будет запущен в режиме REPL.
Если вы попробуете сейчас ввести такую команду в своём терминале, то в результате увидите
примерно следующее:

```
> node
>
```

Node.js теперь находится в режиме ожидания. Система ждёт, что мы введём в командной строке
какой-нибудь JavaScript-код, который она будет выполнять. Сам режим полезен для того, чтобы просматривать
методы глобального API для Node JS. Введите в командную строку имя какого-нибудь стандартного объекта JavaScript,
например — Number, добавьте после него точку и нажмите клавишу Tab.
REPL выведет список свойств и методов объекта, с которыми может взаимодействовать разработчик.
Для того чтобы узнать, с какими глобальными объектами Node.js вы можете работать, введите в
терминале команду global. и нажмите Tab.

---

## npm, файлы package.json и package-lock.json

### Обновление пакетов

Для обновления пакетов служит следующая команда:

```
npm update
```

Получив эту команду, npm проверит все пакеты на наличие их новых версий, и, если найдёт их новые
версии, соответствующие ограничениям на версии пакетов, заданным в package.json, установит их.
Обновить можно и отдельный пакет:

```
npm update <package-name>
```

### Глобальная установка пакетов

Глобальная установка пакетов выполняется с использованием флага -g:

```
npm install -g lodash
```

Выполняя такую команду, npm не устанавливает пакет в локальную папку проекта. Вместо этого он
копирует файлы пакета в некое глобальное расположение. Куда именно попадают эти файлы?
Для того чтобы это узнать, воспользуйтесь следующей командой:

```
npm root -g
```

### Использование npx

Итак, после установки пакета с использованием команды npm install cowsay, он, вместе со своими
зависимостями, попадёт в node_modules. А в скрытую папку .bin будут записаны символические
ссылки на бинарные файлы cowsay (пакет представляет собой исполняемый файлы). Как их выполнять?

Конечно, можно, для вызова программы, ввести в терминале нечто вроде
`./node_modules/.bin/cowsay`. Это рабочий подход, но гораздо лучше воспользоваться npx,
средством для запуска исполняемых файлов npm-пакетов, включаемым в npm начиная с версии 5.2. А
именно, в нашем случае понадобится такая команда:

```
npx cowsay
```

Путь к пакету npx найдёт автоматически.
В npx имеется ещё одна интереснейшая возможность, благодаря которой утилиты можно запускать без
их предварительной установки.

### О версиях пакетов и семантическом версионировании

Учитывая то, что при использовании семантического версионирования все номера версий пакетов
состоят из последовательностей, представляющих собой три числа, о смысле которых мы говорили
выше, опишем следующие правила использования спецификаторов версий:

- ~: если вы задаёте версию в виде ~0.13.0 это означает, что вас интересуют лишь патч-релизы
  пакета. То есть, пакет 0.13.1 вам подойдёт, а 0.14.0 — нет.
- ^: если номер версии задан в виде ^0.13.0, это означает, что вам подходят новые патч-версии
  и минорные версии пакета. То есть, вас устроят версии пакета 0.13.1, 0.14.0, и так далее.
- \*: воспользовавшись этим символом, вы сообщаете системе, что вас устроят любые свежие
  версии пакета, в том числе — его новые мажорные релизы.
- \>: подходят любые версии пакета, которые больше заданной.
- \>=: подходят любые версии пакета, которые равны или больше заданной.
- <=: вас устроят пакеты, версии которых равны заданной или меньше её.
- <: вас интересуют пакеты, версии которых меньше заданной.
- =: вам нужна только заданная версия пакета.
- -: используется для указания диапазона подходящих версий, например — 2.1.0 - 2.6.2.
- ||: позволяет комбинировать наборы условий, касающихся пакетов. Например, это может
  выглядеть как < 2.1 || > 2.6.

Есть и ещё некоторые правила:

- отсутствие дополнительных символов: если используется номер версии пакета без
  дополнительных символов, это значит, что вашему пакету нужна только заданная версия
  пакета-зависимости и никакая другая.
- latest: указывает на то, что вам требуется самая свежая версия некоего пакета

Большинство вышеописанных спецификаторов можно комбинировать, например, задавая диапазоны
подходящих версий пакетов-зависимостей. Скажем, конструкция вида `1.0.0 || >=1.1.0 <1.2.0`
указывает на то, что планируется использовать либо версию пакета 1.0.0, либо версию, номер
которой больше или равен 1.1.0, но меньше 1.2.0.

### Выяснение версий установленных npm-пакетов

1.  Для того чтобы узнать версии всех установленных в папке проекта npm-пакетов, включая их
    зависимости, выполните следующую команду:

        ```
        npm list
        ```

2.  Для того чтобы получить подобный список пакетов, установленных глобально, можно воспользоваться
    следующей командой:

        ```
        npm list -g
        ```

3.  Вывести только сведения о локальных пакетах верхнего уровня (то есть, тех, которые вы
    устанавливали самостоятельно и которые перечислены в package.json) можно так:

    ```
    npm list --depth=0
    ```

4.  Если вы хотите узнать о том, каков номер самой свежей версии некоего пакета, доступного в
    npm-репозитории, вам понадобится команда следующего вида:

    ```
    npm view <package> version
    ```

    В ответ она выдаёт номер версии пакета

5.  Установить нужную версию пакета из npm можно, воспользовавшись следующей конструкцией:

    ```
    npm install <package>@<version>
    ```

### Обновление зависимостей проекта до их самых свежих версий

1.  Если, например, выходит новая минорная версия пакета и мы выполняем команду `npm update`, то
    обновляется установленная версия пакета и при этом сведения об установленном пакете обновляются
    в файле package-lock.json, а файл package.json остаётся неизменным.
    Для того чтобы узнать, вышли ли новые версии используемых в проекте пакетов, можно
    воспользоваться следующей командой:

        ```
        npm outdated
        ```

2.  Некоторые из доступных обновлений пакетов представляют собой их мажорные релизы, обновления до
    которых не произойдёт при выполнении команды npm update. Обновление до мажорных релизов этой
    командой не производится, так как они (по определению) могут содержать серьёзные изменения, не
    отличающиеся обратной совместимостью с предыдущими мажорными релизами, а npm стремится
    избавить разработчика от проблем, которые может вызвать использование подобных пакетов.
    Для того чтобы обновиться до новых мажорных версий всех используемых пакетов, глобально
    установите пакет `npm-check-updates`, а затем запустить утилиту, предоставляемую им:

    ```
    npm install -g npm-check-updates
    ncu -u
    ```

    Эта команда обновит файл package.json, внеся изменения в указания о подходящих версиях
    пакетов в разделы dependencies и devDependencies. Это позволит npm обновить пакеты,
    используемые в проекте, до новых мажорных версий после запуска команды npm update.

### Локальная или глобальная деинсталляция пакетов

Для того чтобы деинсталлировать пакет, ранее установленный локально, выполните команду следующего вида:

```
npm uninstall <package-name>
```

Если пакет установлен глобально, то для его удаления нужно будет воспользоваться флагом -g
(--global). Например, подобная команда может выглядеть так:

```
npm uninstall -g webpack
```

---

## Цикл событий

### Работа со временем

В Node.js функции для работы с таймерами входят в модуль timer, но пользоваться ими можно, не подключая этот модуль в коде, так
как они являются глобальными.

1. process.nextTick()

   Метод process.nextTick() по-особому взаимодействует с циклом событий. Тиком (tick) называют
   один полный проход цикла событий. Передавая функцию методу process.nextTick(), мы сообщаем
   системе о том, что эту функцию нужно вызвать после завершения текущей итерации цикла событий, до
   начала следующей.

   ```js
   process.nextTick(() => {
     // выполнить какие-то действия
   });
   ```

   Предположим, цикл событий занят выполнением кода текущей функции. Когда эта операция
   завершается, JavaScript-движок выполнит все функции, переданные `process.nextTick()` в ходе
   выполнения предыдущей операции. Используя этот механизм, мы стремимся к тому, чтобы некая
   функция была бы выполнена асинхронно (после текущей функции), но как можно скорее, без
   постановки её в очередь.

   Например, если воспользоваться конструкцией `setTimeout(() => {}, 0)` функция будет
   выполнена на следующей итерации цикла событий, то есть — гораздо позже, чем при использовании в
   такой же ситуации `process.nextTick()`. Этот метод стоит использовать тогда, когда нужно
   обеспечить выполнение некоего кода в самом начале следующей итерации цикла событий.

2. setImmediate()

   Ещё одной функцией, предоставляемой Node.js для асинхронного выполнения кода, является
   setImmediate(). Вот как ей пользоваться:

   ```
   setImmediate(() => {
     // выполнить некий код
   })
   ```

   Функция обратного вызова, переданная setImmediate(), будет выполнена на следующей итерации
   цикла событий.

   Вызов функции setTimeout() с установленной задержкой в 0 мс очень похож на вызов
   setImmediate(). Порядок выполнения функций, переданных им, зависит от различных факторов, но
   и в том и в другом случаях коллбэки будут вызваны на следующей итерации цикла событий.

3. setTimeout()

   Функция setTimeout() принимает коллбэк и время, в миллисекундах, по
   прошествии которого будет вызван коллбэк. Пример:

   ```js
   setTimeout(() => {
     // выполняется через 2 секунды
   }, 2000);
   ```

   В результате работы функции возвращается идентификатор таймера. Обычно он не используется, но его
   можно сохранить, и, при необходимости, удалить таймер, если в запланированном выполнении
   коллбэка больше нет необходимости:

   ```js
   const id = setTimeout(() => {
     // этот код должен выполниться через 2 секунды
   }, 2000);

   // Программист передумал, выполнять этот код больше не нужно
   clearTimeout(id);
   ```

   Также, можно использовать setTimeout(), передавая ей, в качестве времени, по
   истечении которого надо вызвать коллбэк, 0. Это означало, что коллбэк будет вызван так скоро, как это
   возможно, но после завершения выполнения текущей функции.
   Этот приём особенно полезен в ситуациях, когда, при выполнении тяжёлых вычислительных задач, не
   хотелось бы блокировать главный поток, позволяя выполняться и другим функциям, разбивая
   подобные задачи на несколько этапов.

4. Рекурсивная установка setTimeout()

   Функция setInterval() будет вызывать переданный ей коллбэк каждые n миллисекунд, не заботясь
   о том, завершилось ли выполнение этого коллбэка после его предыдущего вызова.
   При использовании setInterval() может возникнуть ситуация, когда выполнение коллбэка занимает
   время, превышающее n, что приводит к тому, что следующий вызов осуществляется до завершения
   предыдущего.

   Для того чтобы избежать подобной ситуации, можно воспользоваться методикой рекурсивной
   установки таймера с помощью setTimeout(). Речь идёт о том, что следующий вызов коллбэка
   планируется после завершения его предыдущего вызова:

   ```js
   const myFunction = () => {
     // выполнить некие действия

     setTimeout(myFunction, 1000);
   };

   setTimeout(myFunction, 1000);
   ```

---

## Асинхронность в JavaScript

### Обработка ошибок в коллбэках

Обработка ошибок заключается в том, что первым
параметром любой функции обратного вызова делают объект ошибки. При отсутствии ошибок в этот
параметр будет записано значение null. В противном случае тут будет объект ошибки, содержащий
её описание и дополнительные сведения о ней. Пример:

```js
fs.readFile("/file.json", (err, data) => {
  if (err !== null) {
    //обработаем ошибку
    console.log(err);
    return;
  }

  //ошибок нет, обработаем данные
  console.log(data);
});
```

### Promise

1. Promise.all()

   Если вам нужно выполнить некое действие после разрешения нескольких промисов, сделать это можно
   с помощью команды Promise.all(). Пример:

   ```js
   const f1 = fetch("https://jsonplaceholder.typicode.com/todos/1");
   const f2 = fetch("https://jsonplaceholder.typicode.com/todos/2");

   Promise.all([f1, f2])
     .then((res) => {
       console.log("Array of results", res);
     })
     .catch((err) => {
       console.error(err);
     });
   ```

   В ES2015 появился синтаксис деструктурирующего присваивания, с его использованием можно
   создавать конструкции следующего вида:

   ```js
   Promise.all([f1, f2]).then(([res1, res2]) => {
     console.log("Results", res1, res2);
   });
   ```

2. Promise.race()

   Позволяет выполнить заданное действие после того, как будет разрешён
   один из переданных ей промисов. Соответствующий коллбэк, содержащий результаты этого первого
   промиса, вызывается лишь один раз. Рассмотрим пример:

   ```js
   const first = new Promise((resolve, reject) => {
     setTimeout(resolve, 500, "first");
   });
   const second = new Promise((resolve, reject) => {
     setTimeout(resolve, 100, "second");
   });

   Promise.race([first, second]).then((result) => {
     console.log(result); // second
   });
   ```

3. async/await

   Если объявить некую функцию с использованием ключевого слова async, это будет означать, что
   такая функция возвратит промис даже если в явном виде это не делается. Пример:

   ```js
   const aFunction = async () => {
     return "test";
   };
   ```

   Эта конструкция аналогична такой:

   ```js
   const aFunction = async () => {
     return Promise.resolve("test");
   };
   ```

---

## Протоколы HTTP и WebSocket

### Отправка запроса

Запрос представляет собой структурированный в соответствии с правилами используемого протокола
фрагмент текста. Он состоит из трёх частей:

- Строка запроса.
- Заголовок запроса.
- Тело запроса.

Про каждое отдельно.

1. Строка запроса

   Строка запроса представляет собой одну текстовую строку, в которой содержатся следующие
   сведения:

   - Метод HTTP.
   - Адрес ресурса.
   - Версия протокола

   Выглядеть она, например, может так:

   ```
   GET / HTTP/1.1
   ```

2. Заголовок запроса

   Заголовок запроса представлен набором пар вида поле: значение. Существуют 2 обязательных
   поля заголовка, одно из которых — Host, а второе — Connection. Остальные поля необязательны.
   Пример:

   ```
   Host: flaviocopes.com

   Connection: close
   ```

   Поле Host указывает на доменное имя, которое интересует браузер. Поле Connection,
   установленное в значение close, означает, что соединение между клиентом и сервером не нужно
   держать открытым. Заголовок запроса завершается пустой строкой.

3. Тело запроса

   Тело запроса необязательно, в GET-запросах оно не используется. Тело запроса используется в
   POST-запросах, а также в других запросах. Оно может содержать, например, данные в формате JSON.
   Так как сейчас речь идёт о GET-запросе, тело запроса будет пустым, с ним мы работать не будем.

### Отличия WebSocket от HTTP

HTTP и WebSocket — это очень разные протоколы, в которых используются различные подходы к
обмену данными. HTTP основан на модели «запрос — ответ»: сервер отправляет клиенту некие
данные после того, как они будут запрошены. В случае с WebSocket всё устроено иначе. А именно:

- Сервер может отправлять сообщения клиенту по своей инициативе, не дожидаясь поступления
  запроса от клиента.
- Клиент и сервер могут обмениваться данными одновременно.
- При передаче сообщения используется крайне малый объём служебных данных. Это, в
  частности, ведёт к низким задержкам при передаче данных.

Протокол WebSocket очень хорошо подходит для организации связи в режиме реального времени по
каналам, которые долго остаются открытыми. HTTP, в свою очередь, отлично подходит для
организации эпизодических сеансов связи, инициируемых клиентом. В то же время надо отметить, что,
с точки зрения программирования, реализовать обмен данными по протоколу HTTP гораздо проще, чем
по протоколу WebSocket.

### Защищённая версия протокола WebSocket

Существует небезопасная версия протокола WebSocket (URI-схема ws://), которая напоминает, в
плане защищённости, протокол http://. Использования ws:// следует избегать, отдавая
предпочтение защищённой версии протокола — wss://.

---

## Пути к файлам

Путь к файлу — это адрес того места в файловой системе, где он расположен.
В Linux и macOS путь может выглядеть так:

```
/users/flavio/file.txt
```

В Windows пути выглядят немного иначе:

```
C:\users\flavio\file.txt
```

На различия в форматах записи путей при использовании разных операционных систем следует
обращать внимание, учитывая операционную систему, используемую для развёртывания
Node.js-сервера.

В Node.js есть стандартный модуль path, предназначенный для работы с путями к файлам. Перед
использованием этого модуля в программе его надо подключить:

```js
const path = require("path");
```

---
