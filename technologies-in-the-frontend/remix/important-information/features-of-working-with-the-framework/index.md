# Особенности работы с фреймворком

## Начало работы

Перед началом работы внимательно прочитайте [документацию Remix](https://remix.run/docs/en/v1) и документацию, которая существует на проекте.
Лучше несколько раз, если есть возможность! Советую ознакомиться с [демо-приложением от создателей Remix](https://remix.run/docs/en/v1/tutorials/jokes),
которое наглядно иллюстрирует основные концепции инструмента и то как с ними работать. Также, у одного из создателей Remix Райна Флорена
есть [отличный плейлист](https://www.youtube.com/watch?v=jd_bin5HPrw&list=PLXoynULbYuEDG2wBFSZ66b85EIspy3fy6&ab_channel=Remix)
на официальном YouTube канале Remix, посвящённый тому, как создавать повседневные решения, связанные с функциональной частью.

## Неявный роутинг

В документации есть несколько примеров, которые отсылаются к идеям неявного роутинга.
Но, к сожалению, раскрыты они не так хорошо, как бы хотелось. Разбираемся, что не так:

1. Пример первый:

```

routes/feedbacks.tsx
routes/feedbacks/index.tsx
routes/feedbacks/$userId/index.tsx

```

Простыми словами: файл `routes/feedbacks.tsx` является оболочкой для всех вложенных в него файлов.
То есть компоненты, стили и функциональность данного файла будут присутствовать **на всех страницах**, которые соответствуют этому маршруту.
Классический пример такого же подхода - компонент MainLayout.
Он располагается в root.tsx файле, который является оболочкой для любого маршрута. Именно поэтому компонент доступен везде.

2. Второй пример:

```

routes/feedbacks/index.tsx
routes/feedbacks/$userId/index.tsx

```

Совершенно противоположная ситуация. Файл `routes/feedbacks/index.tsx` является одной страницей,
а файл `routes/feedbacks/$userId/index.tsx` другой. Их компоненты, стили и функциональность никак не пересекаются.

Какой из этих двух случаев выбирать, зависит от дизайна системы.

## Границы ошибок

Советую ознакомиться с [этим разделом](https://remix.run/docs/en/v1/guides/errors#root-error-boundary) документацией.

Для удобной работы с ошибками Remix API предоставляет нам ErrorBoundary и CatchBoundary. Данные функции могут быть размещены только
в файлах, которые находятся в папке routes. На данный момент в проекте существует глобальные 404 и 505 страницы, условия отображения которых
находятся в файле root.tsx. Если произойдёт ошибка в node api или браузерной api, то она попадёт именно в этот файл, и в зависимости
от статуса отобразится соответствующая страница. Для большинства моментов в приложении этого более чем достаточно.
Однако, если вы хотите добавить свою обработку ошибки с помощью ErrorBoundary или CatchBoundary, в определённом файле роутера, то не
стесняйтесь это сделать!

## Типизация loader и action функций

Из документации вы можете узнать, что loader и action реализуют одно и то же API. Разница между ними заключается в том, когда
фреймворк вызывает эти функции. Для типизации этих сущностей существует ровно один интерфейс - LoaderFunction. Пример:

```js
export const loader: LoaderFunction = async () => {
  // ...
};

export const action: LoaderFunction = async () => {
  // ...
};
```

## Архитектура

Чтобы увидеть проблему на берегу, ознакомьтесь со [статьёй про архитектурные паттерны](https://doka.guide/js/architecture-mvc/#model-view-presenter).
В ней описываются разные архитектурные модели взаимодействия слоёв данных. На одной из них построен фреймворк Remix, а именно MVP модель.
Обратимся к тексту статьи, чтобы раскрыть преимущества и недостатки такой модели взаимодействия данных:

> Плюс такого подхода в том, что не возникает вопросов, какой код к чему относится.
> Минус — в том, что презентер быстро становится большим и сложным.
> Приходится разбивать его на модули поменьше, вероятно, добавлять дополнительные «слои».

Вывод: **следите за состоянием loader и action API**.
Пишите структурированный и простой код, выносите дополнительные обработчики в папку helpers.
Не позволяйте вашему коду превращаться в нечитаемую портянку.
