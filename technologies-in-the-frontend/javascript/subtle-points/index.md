# Тонкие моменты

## Браузерное окружение

- prompt. Показывает сообщение и запрашивает ввод текста от пользователя. Возвращает напечатанный в поле ввода текст или null, если была нажата кнопка «Отмена» или Esc с клавиатуры. Лучше всего всегда устанавливать значение по умолчанию!

  ```js
  let test = prompt("Test", "");
  ```

- confirm. показывает сообщение и ждёт, пока пользователь нажмёт OK или Отмена. Возвращает true, если нажата OK, и false, если нажата кнопка «Отмена» или Esc с клавиатуры.

## Операторы

- Нулевое слияния и "логическое или". Важное различие между ними заключается в том, что:

  ```
  || - возвращает первое истинное значение.
  ?? - возвращает первое определённое значение.
  ```

- По соображениям безопасности JavaScript запрещает использование оператора ?? вместе с && и ||, если приоритет явно не указан при помощи круглых скобок.

  ```js
  let x = 1 && 2 ?? 3; // Синтаксическая ошибка
  ```

## Числа

- Обычные числа в JavaScript хранятся в 64-битном формате IEEE-754, который также называют «числа с плавающей точкой двойной точности» (double precision floating point numbers). Это числа, которые мы будем использовать чаще всего. Мы поговорим о них в этой главе.

- Числовой формат IEEE-754 решает проблему манипуляции с дробными числами путём округления до ближайшего возможного числа. Правила округления обычно не позволяют нам увидеть эту «крошечную потерю точности», но она ВСЕГДА существует.

- Функция parseInt() имеет необязательный второй параметр. Он определяет систему счисления, таким образом parseInt может также читать строки с шестнадцатеричными числами, двоичными числами и т.д.:

  ```js
  alert(parseInt("0xff", 16)); // 255
  alert(parseInt("ff", 16)); // 255, без 0x тоже работает

  alert(parseInt("2n9c", 36)); // 123456
  ```

- Math.random()
  Возвращает псевдослучайное число в диапазоне от 0 (включительно) до 1 (но не включая 1). Поэтому, не стоит забывать, что число 0 - это тоже возможный вариант событий!

- Методы Math.round и toFixed, согласно документации, округляют до ближайшего целого числа: 0..4 округляется в меньшую сторону, тогда как 5..9 в большую сторону.

  ```js
  alert((1.35).toFixed(1)); // 1.4
  alert((6.35).toFixed(1)); // 6.3
  ```

  _Вопрос_: что произошло с 6.35?
  _Ответ_: Во внутреннем двоичном представлении 6.35 является бесконечной двоичной дробью. Хранится она с потерей точности:

  ```js
  alert((6.35).toFixed(20)); // 6.34999999999999964473
  alert((1.35).toFixed(20)); // 1.35000000000000008882
  ```

  Потеря точности может как увеличивать, так и уменьшать число. В случае c 6.35 число становится чуть меньше, поэтому оно округляется в меньшую сторону. Каким образом можно исправить ошибку в округлении числа 6.35? Написать собственную функцию для точного округления чисел:

  ```js
  function exactRound(number) {
    Math.round(number * 10) / 10;
  }

  exactRound(6.35); // 6.35 -> 63.5 -> 64(rounded) -> 6.4
  ```

  Обратите внимание, что для числа 63.5 не происходит потери точности. Дело в том, что десятичная часть 0.5 на самом деле 1/2. Дробные числа, делённые на степень 2, точно представлены в двоичной системе, теперь мы можем округлить число.

## Массивы

- Array.sort(fn)

  Он возвращает отсортированный массив, но обычно возвращаемое значение игнорируется, так как изменяется сам arr. _По умолчанию элементы сортируются как строки._

  Чтобы использовать наш собственный порядок сортировки, нам нужно предоставить функцию в качестве аргумента arr.sort().

  ```js
  function compareNumeric(a, b) {
    if (a > b) return 1;
    if (a == b) return 0;
    if (a < b) return -1;
  }

  let arr = [2, 1, 15];

  arr.sort(compareNumeric);

  alert(arr); // 1, 2, 15
  ```

  Метод arr.sort(fn) реализует общий алгоритм сортировки. Нам не нужно заботиться о том, как он работает внутри (в большинстве случаев это оптимизированная быстрая сортировка или Timsort). Она проходится по массиву, сравнивает его элементы с помощью предоставленной функции и переупорядочивает их. Всё, что остаётся нам, это предоставить fn, которая делает это сравнение. На самом деле от функции сравнения требуется любое положительное число, чтобы сказать «больше», и отрицательное число, чтобы сказать «меньше». Это позволяет писать более короткие функции:

  ```js
  let arr = [2, 1, 15];

  arr.sort((a, b)  => a - b;
  );

  alert(arr); // 1, 2, 15
  ```

  Кстати, если мы когда-нибудь захотим узнать, какие элементы сравниваются – ничто не мешает нам вывести их на экран:

  ```js
  [1, -2, 15, 2, 0, 8].sort(function (a, b) {
    alert(a + " <> " + b);
    return a - b;
  });
  ```

- Обратите внимание, что методы sort, reverse и splice изменяют исходный массив.

## Map и Set

1. Map – коллекция пар ключ-значение. Отличия от обычного объекта Object:

   - Что угодно может быть ключом, в том числе и объекты.
   - Есть дополнительные методы, свойство size.

2. Set – коллекция уникальных значений, так называемое «множество».

## WeakMap и WeakSet

WeakSet – это Set-подобная коллекция, которая хранит только объекты и удаляет их, как только они становятся недостижимыми иными путями.

Обе этих структуры данных не поддерживают методы и свойства, работающие со всем содержимым сразу или возвращающие информацию о размере коллекции. Возможны только операции на отдельном элементе коллекции.

WeakMap и WeakSet используются как вспомогательные структуры данных в дополнение к «основному» месту хранения объекта. Если объект удаляется из основного хранилища и нигде не используется, кроме как в качестве ключа в WeakMap или в WeakSet, то он будет удалён автоматически.
