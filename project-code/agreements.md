# Основные договорённости

## Договорённости по CSS

1. Позиционирование (position, top, left, right, bottom, z-index и т.д.)
2. Блочная модель (display, flex, align-items, width, height, grid и т.д.)
3. Отступы (margin, padding)
4. Свойства блока (bg, border, box-shadow, opacity , visibility и т.д.)
5. Свойства шрифтов (font-size, line-height , letter-spacing и т.д )
6. Остальные (transform, transition, overflow, cursor, visibility, opacity и т.д.)

В папке constants/css хранятся все необходимые константы

# Договорённости по импортам

1. Внешние библиотеки (node_modules)
2. Сторы , селекторы
3. Файлы с путями алиасов (@components/... ; @constants/... ; @shared/... ; @typesTS/...)
4. Файлы с путями от текущего файла (./types ; ./helpers)
5. Стили

# Договорённости по функциональной части компонента

1. Стейты , Cелекторы , Константы
2. Функции
3. Эффекты
4. Return

Перед return всегда ставим пробел для читаемости. Семантически одинаковые сущности в пункте 1 отделяются друг от друга пробелом

# Договорённости по именованию цветов

Мы не называем цвета по типу grayFirst, graySecond и так далее. Чтобы правильно обозначить цветовую константу мы используем данный ресурс (https://colornamer.robertcooper.me/). Вбиваем цвет в формате RGB и получаем соответствующее название. Далее оно записывается в папку constants в формате SNAKE_CASE. Если понадобится особый формат цвета, по типу RGBA - то мы превращаем его в RGB, записываем в константу и в конце названия указываем формат(например TROFOL_GREEN_RGBA)

# Договорённости по Redux-saga

1. В конце названия саги-вотчера ставится Flow (например resetFlow)
2. В конце названия саги-воркера ставится Saga (например firstStepHandlerSaga)
3. В конце названия сервиса для саги-воркера ставится Service (например changeUserPasswordService)
4. В начале каждой саги-воркера перед блоком try ставится console.log(`${имя саги-воркера} started`)

# Договорённости по Redux-thunk

1. В названии сервиса в конце ставится Service (например changeUserPasswordService)
2. В начале каждого сервиса перед блоком try ставится console.log(`${имя сервиса} started`)

# Договорённости по TS сущностям (enum и type)

1. Названия Enum начинается с E (например EResetNames), а Type с T (например TResetUser)
2. Над каждым полем в Type нужно ставить многострочный комментарий (например /_ Текст _/) и описывать, что оно обозначает

Теперь к более насущному. В компоненте есть переменная shouldErrorComponentRender, типа boolean. В один прекрасный момент бизнес логика выросла в объёме и вам потребовалось дополнить эту переменную. Теперь тип этой переменной, при наведении на неё, выглядит так:

```javascript
const shouldErrorComponentRender = boolean | string | TDictionaryMenu | null;
```

В данном случае, в вашей картине мира , очевидно, что пустая строка и не заинициолизированный объект в булевской логике - это ноль. Но если взглянуть на ситуацию трезво, вы усложнили простейшую переменную в рамках типов до абсурда. Если ваша переменная содержит несколько сущностей, пожалуйста, обязательно приводите всё к одному типу с помощью обёрток по типу Number, String, Boolean. Пример:

Неправильно:

```javascript
const shouldErrorComponentRender = false | "абракадабра" | futureConfig;
```

Правильно:

```javascript
const shouldErrorComponentRender =
  false | Boolean("абракадабра") | Boolean(futureConfig);
```
