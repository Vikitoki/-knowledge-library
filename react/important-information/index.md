# Важная информация

---

## JSX

### JSX это тоже выражение

После компиляции каждое JSX-выражение становится обычным вызовом JavaScript-функции, результат которого — объект JavaScript.
Из этого следует, что JSX можно использовать внутри инструкций if и циклов for, присваивать переменным, передавать функции в качестве аргумента и возвращать из функции.

```jsx
function getGreeting(user) {
  if (user) {
    return <h1>Здравствуй, {formatName(user)}!</h1>;
  }
  return <h1>Здравствуй, незнакомец.</h1>;
}
```

### JSX предотвращает атаки, основанные на инъекции кода

```jsx
const title = response.potentiallyMaliciousInput;
// Этот код безопасен:
const element = <h1>{title}</h1>;
```

По умолчанию React DOM экранирует все значения, включённые в JSX перед тем как отрендерить их. 
Это гарантирует, что вы никогда не внедрите чего-либо, что не было явно написано в вашем приложении. 
Всё преобразуется в строчки, перед тем как быть отрендеренным. 
Это помогает предотвращать атаки межсайтовым скриптингом (XSS).


### Использование записи через точку

Вы также можете ссылаться на React-компонент, используя запись через точку. 
Это удобно, если у вас есть модуль, который экспортирует много React-компонентов. 
К примеру, если MyComponents.DatePicker является компонентом, то вы можете обратиться к нему напрямую, 
используя запись через точку:

```jsx
import React from 'react';

const MyComponents = {
  DatePicker: function DatePicker(props) {
    return <div>Представьте, что здесь цвет {props.color} виджета выбора даты.</div>;
  }
}

function BlueDatePicker() {
  return <MyComponents.DatePicker color="blue" />;
}
```

### Логические значения, null и undefined игнорируются

Значения false, null, undefined и true — валидные дочерние компоненты. Просто они не рендерятся.

Есть один нюанс в том, что React будет рендерить «ложные» (falsy) значения, такие как число 0. 
Код ниже ведёт себя не так, как вы могли ожидать, так как 0 будет отображён, если массив props.messages пуст:

```jsx
<div>
  {props.messages.length &&
    <MessageList messages={props.messages} />
  }
</div>
```

Чтобы исправить это, убедитесь что выражение перед оператором && всегда является boolean:

```jsx
<div>
  {props.messages.length > 0 &&
    <MessageList messages={props.messages} />
  }
</div>
```

И наоборот, если вы хотите, чтобы такие значения как false, true, null или undefined отрисовались, 
то сначала вы должны преобразовать их в строку:

```jsx
<div>
  Моя переменная JavaScript - {String(myVariable)}.
</div>
```

---

## Названия компонентов

Всегда называйте компоненты с заглавной буквы. Если компонент начинается с маленькой буквы, React принимает его за DOM-тег. 
Например, <div /> это div-тег из HTML, а <Welcome /> это уже наш компонент Welcome, который должен быть в области видимости

---

## Извлечение компонентов 

Если вы не уверены, извлекать компонент или нет, вот простое правило. 
Если какая-то часть интерфейса многократно в нём повторяется (Button, Panel, Avatar) или сама по себе достаточно сложная 
(App, FeedStory, Comment), имеет смысл её вынести в независимый компонент.

---

## this в компонентах 

При обращении к this в JSX-колбэках необходимо учитывать, что методы класса в JavaScript по умолчанию не привязаны к контексту. 
Если вы забудете привязать метод this.handleClick и передать его в onClick, значение this будет undefined в момент вызова функции.

Дело не в работе React, это часть того, как работают функции в JavaScript. 
Обычно, если ссылаться на метод без () после него, например, onClick={this.handleClick}, этот метод нужно привязать. Пример:

```jsx 
class Toggle extends React.Component {
  constructor(props) {
    super(props);
    this.state = {isToggleOn: true};

    // Эта привязка обязательна для работы `this` в колбэке.
    this.handleClick = this.handleClick.bind(this);
  }

  handleClick() {
    this.setState(prevState => ({
      isToggleOn: !prevState.isToggleOn
    }));
  }

  render() {
    return (
      <button onClick={this.handleClick}>
        {this.state.isToggleOn ? 'Включено' : 'Выключено'}
      </button>
    );
  }
}

ReactDOM.render(
  <Toggle />,
  document.getElementById('root')
);
```

---

## Однонаправленный поток данных

В иерархии компонентов ни родительский, ни дочерние компоненты не знают, задано ли состояние другого компонента. 
Также не важно, как был создан определённый компонент — с помощью функции или с помощью класса.

Состояние часто называют «локальным», «внутренним» или инкапсулированным. 
Оно доступно только для самого компонента и скрыто от других.

Компонент может передать своё состояние вниз по дереву в виде пропсов дочерних компонентов. 
Это, в общем, называется «нисходящим» («top-down») или «однонаправленным» («unidirectional») потоком данных. 
Состояние всегда принадлежит определённому компоненту, а любые производные этого состояния могут влиять только на компоненты, 
находящиеся «ниже» в дереве компонентов.

---

## Особенности API

### React key 

Ключи должны быть уникальными среди соседних элементов.
Ключи внутри массива должны быть уникальными только среди своих соседних элементов. 
Им не нужно быть уникальными глобально. Можно использовать один и тот же ключ в двух разных массивах.
Пример:

```jsx
function Blog(props) {
  const sidebar = (
    <ul>
      {props.posts.map((post) =>
        <li key={post.id}>
          {post.title}
        </li>
      )}
    </ul>
  );
  const content = props.posts.map((post) =>
    <div key={post.id}>
      <h3>{post.title}</h3>
      <p>{post.content}</p>
    </div>
  );
  return (
    <div>
      {sidebar}
      <hr />
      {content}
    </div>
  );
}

const posts = [
  {id: 1, title: 'Привет, мир', content: 'Добро пожаловать в документацию React!'},
  {id: 2, title: 'Установка', content: 'React можно установить из npm.'}
];
ReactDOM.render(
  <Blog posts={posts} />,
  document.getElementById('root')
);
```

### React.lazy

Функция React.lazy позволяет рендерить динамический импорт как обычный компонент. 
React.lazy принимает функцию, которая должна вызвать динамический import(). 
Результатом возвращённого Promise является модуль, который экспортирует **по умолчанию (export default)** React-компонент.

Компонент с ленивой загрузкой должен рендериться внутри компонента Suspense, который позволяет 
нам показать запасное содержимое (например, индикатор загрузки) пока происходит загрузка ленивого компонента.

Проп fallback принимает любой React-элемент, который вы хотите показать, пока происходит загрузка компонента. 
Компонент Suspense можно разместить в любом месте над ленивым компонентом. 
Кроме того, можно обернуть несколько ленивых компонентов одним компонентом Suspense.

```jsx
import React, { Suspense } from 'react/index';

const OtherComponent = React.lazy(() => import('./OtherComponent'));

function MyComponent() {
  return (
    <div>
      <Suspense fallback={<div>Загрузка...</div>}>
        <OtherComponent />
      </Suspense>
    </div>
  );
}
```

### React предохранители

Если какой-то модуль не загружается (например, из-за сбоя сети), это вызовет ошибку. 
Вы можете обрабатывать эти ошибки для улучшения пользовательского опыта с помощью Предохранителей. 
После создания предохранителя, его можно использовать в любом месте над ленивыми компонентами для отображения состояния ошибки.

Классовый компонент является предохранителем, 
если он включает хотя бы один из следующих методов жизненного цикла: static getDerivedStateFromError() или componentDidCatch().
Используйте static getDerivedStateFromError() при рендеринге запасного UI в случае отлова ошибки. 
Используйте componentDidCatch() при написании кода для журналирования информации об отловленной ошибке.
Обратите внимание, что предохранители отлавливают ошибки **исключительно в своих дочерних компонентах**.

Начиная с React 16, ошибки, не отловленные ни одним из предохранителей, 
будут приводить к размонтированию всего дерева компонентов React.

Код компонента ErrorBoundary можно посмотреть [здесь](../ready-solutions/index.md)

```jsx
import React, { Suspense } from 'react';
import ErrorBoundary  from './ErrorBoundary';

const OtherComponent = React.lazy(() => import('./OtherComponent'));
const AnotherComponent = React.lazy(() => import('./AnotherComponent'));

const MyComponent = () => (
  <div>
    <ErrorBoundary>
      <Suspense fallback={<div>Загрузка...</div>}>
        <section>
          <OtherComponent />
          <AnotherComponent />
        </section>
      </Suspense>
    </ErrorBoundary>
  </div>
);
```

### React Context.Provider

Все потребители, которые являются потомками Provider, будут повторно рендериться, как только проп value у Provider изменится. 
Потребитель (включая .contextType и useContext) перерендерится при изменении контекста, даже если его родитель, 
не использующий данный контекст, блокирует повторные рендеры с помощью shouldComponentUpdate.

### React Profiler

Profiler может быть добавлен в любую часть React-дерева для измерения стоимости рендеринга этой части. 
Он принимает два пропа: id (string) и колбэк onRender (function), который React вызывает каждый раз, 
когда компонент внутри дерева «фиксирует» обновление. 
Для замера разных частей приложения могут быть использованы несколько компонентов Profiler Пример:

```jsx
render(
  <App>
    <Profiler id="Navigation" onRender={callback}>
      <Navigation {...props} />
    </Profiler>
    <Main {...props} />
  </App>
);

render(
  <App>
    <Profiler id="Navigation" onRender={callback}>
      <Navigation {...props} />
    </Profiler>
    <Profiler id="Main" onRender={callback}>
      <Main {...props} />
    </Profiler>
  </App>
);
```

Несмотря на то, что компонент Profiler достаточно легковесный, 
его следует использовать только при необходимости; каждое его использование увеличивает нагрузку на CPU и память.

### React StrictMode

Инструмент для обнаружения потенциальных проблем в приложении.

На данный момент StrictMode помогает в:

- Обнаружении небезопасных методов жизненного цикла
- Предупреждении об использовании устаревшего API строковых реф
- Предупреждении об использовании устаревшего метода findDOMNode
- Обнаружении неожиданных побочных эффектов
- Обнаружении устаревшего API контекста

---

## Виртуализация длинных списков

Если ваше приложение рендерит длинные списки данных (сотни или тысячи строк), 
мы рекомендуем использовать метод известный как «оконный доступ».

react-window и react-virtualized — это популярные библиотеки для оконного доступа. 
Они предоставляют несколько повторно используемых компонентов для отображения списков, сеток и табличных данных.

Ссылки на примеры: 
- <https://react-window.vercel.app/#/examples/list/fixed-size>
- <https://bvaughn.github.io/react-virtualized/>

---

## Атрибуты элементы DOM

### dangerouslySetInnerHTML

Свойству innerHTML в DOM браузера соответствует dangerouslySetInnerHTML в React. 
Как правило, вставка HTML из кода рискованна, так как можно случайно подвергнуть 
ваших пользователей атаке межсайтового скриптинга. 
Таким образом, вы можете вставить HTML непосредственно из React используя dangerouslySetInnerHTML 
и передать объект с ключом __html, чтобы напомнить себе, что это небезопасно. Например:

```jsx
function createMarkup() {
  return {__html: 'Первый &middot; Второй'};
}

function MyComponent() {
  return <div dangerouslySetInnerHTML={createMarkup()} />;
}
```

---

## Словарь терминов React 

Ссылка на источник: <https://ru.reactjs.org/docs/glossary.html>

---

## Хуки

### Какие проблемы решают хуки

1. Повторное использование логики состояний между компонентами (кастомные хуки)
2. Хуки позволяют разбить один компонент на маленькие функции по их назначению
   (например, подписке или загрузке данных), а не на основе методов жизненного цикла.
3. Классовые компоненты могут приводить к ненамеренным паттернам, сводящим оптимизации на нет. Классы создают сложности для инструментов и сегодня.
   Например, классы плохо минифицируются, а горячая перезагрузка (hot reloading) ненадёжна и часто ломает их.
   Кроме этого, работа с побочными эффектами [становится неявной](https://ru.reactjs.org/docs/hooks-effect.html#effects-with-cleanup),
   даже для опытных разработчиков. Хуки позволяют лучше использовать возможности и концепции React без написания классов.

### Эффективность использования хуков

Реализация хуков более эффективна по нескольким причинам:

1. Хуки не требуют больших затрат, которые неизбежны в классах. 
Например, создание экземпляра класса и связывание обработчиков событий в конструкторе.

2. Проект, полностью написанный на хуках, имеет менее глубокое дерево компонентов. 
В случае использования рендер-пропсов, компонентов высшего порядка или контекста, 
финальное дерево компонентов было бы в несколько раз больше. 
Тут стоит понимать, что чем меньше дерево компонентов, тем меньше работы React должен делать.

### Правила хуков

1. Не вызывайте хуки из обычных функций JavaScript. Вместо этого можно:

   - Вызывать хуки из функционального компонента React.
   - Вызывать хуки из пользовательского хука (мы научимся делать это на следующей странице).

2. Пользовательский хук — это JavaScript-функция, 
имя которой начинается с «use». Она может вызывать другие хуки.

### useEffect

1. Если вам знакомы классовые методы жизненного цикла React, 
хук useEffect представляет собой совокупность методов **componentDidMount, componentDidUpdate**, и **componentWillUnmount**.

2. Используя этот хук, вы говорите React сделать что-то **после рендера**. 
React запомнит функцию (то есть «эффект»), которую вы передали и вызовет её после того, как внесёт все изменения в DOM. 
В этом эффекте мы устанавливаем заголовок документа, но мы также можем выполнить запрос данных или вызвать какой-нибудь 
императивный API.

3. В отличие от componentDidMount или componentDidUpdate, эффекты, запланированные с помощью useEffect, 
не блокируют браузер при попытке обновить экран. 
Ваше приложение будет быстрее реагировать на действия пользователя, даже когда эффект ещё не закончился. 
Большинству эффектов не нужно работать в синхронном режиме. 
Есть редкие случаи, когда им всё же нужно это делать (например, измерять раскладку), 
но для этого существует специальный хук useLayoutEffect с точно таким же API, как и у useEffect.

4. Когда именно React будет сбрасывать эффект? 
React будет сбрасывать эффект перед тем, как компонент размонтируется. 
Однако, как мы уже знаем, эффекты выполняются не один раз, а при каждом рендере. 
Вот почему React также сбрасывает эффект из предыдущего рендера, перед тем, как запустить следующий. 
Это позволяет избежать багов.

5. Использование функций, относящихся к побочным эффектам:

👎**Плохо:**

```jsx
function Example({ someProp }) {
  function doSomething() {
    console.log(someProp);
  }

  useEffect(() => {
    doSomething();
  }, []); // Так делать небезопасно (вызывать `doSomething`, который использует `someProp`)
}
```

👍**Хорошо:**

```jsx
function Example({ someProp }) {
  useEffect(() => {
    function doSomething() {
      console.log(someProp);
    }

    doSomething();
  }, [someProp]); // Правильно (наш эффект использует только `someProp`)
}
```

Это помогает замечать, какие пропсы и состояние используются вашим эффектом, и убедиться, 
что они перечислены в списке зависимостей. Это также позволяет обрабатывать ответы, пришедшие не в порядке запросов,
с помощью локальной переменной внутри эффекта:

```jsx
  useEffect(() => {
    let ignore = false;
    async function fetchProduct() {
      const response = await fetch('http://myapi/product/' + productId);
      const json = await response.json();
      if (!ignore) setProduct(json);
    }
    fetchProduct();
    return () => { ignore = true };
  }, [productId]);
```

Если по какой-то причине вы не можете переместить функцию в эффект, есть другие варианты:

  - Можно попробовать поместить функцию снаружи компонента. 
  В таком случае она гарантированно не будет ссылаться на пропсы и состояние, 
  так что её не требуется перечислять в списке зависимостей.
  - Если функция, которую вы вызываете, является чистым вычислением и её безопасно вызывать во время рендера, 
  вы можете вызвать её снаружи эффекта, а не внутри, и сделать эффект зависящим от результата этого вызова, 
  а не от самой функции.
  - В крайнем случае можете добавить саму функцию в список зависимостей эффекта, но обернув её определение в хук useCallback.
  Тогда функция будет оставаться неизменной, до тех пор, пока не изменятся её зависимости.


Статья о загрузке данных с помощью хуков: <https://www.robinwieruch.de/react-hooks-fetch-data/>

6. **Внимание, спорная часть документации**.

Когда вы указываете список зависимостей через последний аргумент хуков **useEffect, useLayoutEffect, useMemo, 
useCallback** или **useImperativeHandle**, в него должны войти все использованные значения, которые задействованы 
в потоке данных React, включая пропсы, состояние и их производные. 
В продолжение этой мысли ссылка на следующий раздел: <https://ru.reactjs.org/docs/hooks-faq.html#what-can-i-do-if-my-effect-dependencies-change-too-often>

### useState

Использование результата функций, в качестве изначального состояния:

👎**Плохо:**

```jsx
function Table(props) {
   // createRows() вызывается на каждом рендере
   const [rows, setRows] = useState(createRows(props.count));
   // ...
}
```

👍**Хорошо:**

```jsx
function Table(props) {
   // createRows() будет вызван только один раз
   const [rows, setRows] = useState(() => createRows(props.count));
   // ...
}
```
