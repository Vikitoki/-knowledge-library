# Важная информация

## JSX

### JSX это тоже выражение

После компиляции каждое JSX-выражение становится обычным вызовом JavaScript-функции, результат которого — объект JavaScript.
Из этого следует, что JSX можно использовать внутри инструкций if и циклов for, присваивать переменным, передавать функции в качестве аргумента и возвращать из функции.

```jsx
function getGreeting(user) {
  if (user) {
    return <h1>Здравствуй, {formatName(user)}!</h1>;
  }
  return <h1>Здравствуй, незнакомец.</h1>;
}
```

### JSX предотвращает атаки, основанные на инъекции кода

```jsx
const title = response.potentiallyMaliciousInput;
// Этот код безопасен:
const element = <h1>{title}</h1>;
```

По умолчанию React DOM экранирует все значения, включённые в JSX перед тем как отрендерить их. 
Это гарантирует, что вы никогда не внедрите чего-либо, что не было явно написано в вашем приложении. 
Всё преобразуется в строчки, перед тем как быть отрендеренным. 
Это помогает предотвращать атаки межсайтовым скриптингом (XSS).

## Названия компонентов

Всегда называйте компоненты с заглавной буквы. Если компонент начинается с маленькой буквы, React принимает его за DOM-тег. 
Например, <div /> это div-тег из HTML, а <Welcome /> это уже наш компонент Welcome, который должен быть в области видимости


## Извлечение компонентов 

Если вы не уверены, извлекать компонент или нет, вот простое правило. 
Если какая-то часть интерфейса многократно в нём повторяется (Button, Panel, Avatar) или сама по себе достаточно сложная 
(App, FeedStory, Comment), имеет смысл её вынести в независимый компонент.


## this в компонентах 

При обращении к this в JSX-колбэках необходимо учитывать, что методы класса в JavaScript по умолчанию не привязаны к контексту. 
Если вы забудете привязать метод this.handleClick и передать его в onClick, значение this будет undefined в момент вызова функции.

Дело не в работе React, это часть того, как работают функции в JavaScript. 
Обычно, если ссылаться на метод без () после него, например, onClick={this.handleClick}, этот метод нужно привязать. Пример:

```jsx 
class Toggle extends React.Component {
  constructor(props) {
    super(props);
    this.state = {isToggleOn: true};

    // Эта привязка обязательна для работы `this` в колбэке.
    this.handleClick = this.handleClick.bind(this);
  }

  handleClick() {
    this.setState(prevState => ({
      isToggleOn: !prevState.isToggleOn
    }));
  }

  render() {
    return (
      <button onClick={this.handleClick}>
        {this.state.isToggleOn ? 'Включено' : 'Выключено'}
      </button>
    );
  }
}

ReactDOM.render(
  <Toggle />,
  document.getElementById('root')
);
```

## Однонаправленный поток данных

В иерархии компонентов ни родительский, ни дочерние компоненты не знают, задано ли состояние другого компонента. 
Также не важно, как был создан определённый компонент — с помощью функции или с помощью класса.

Состояние часто называют «локальным», «внутренним» или инкапсулированным. 
Оно доступно только для самого компонента и скрыто от других.

Компонент может передать своё состояние вниз по дереву в виде пропсов дочерних компонентов. 
Это, в общем, называется «нисходящим» («top-down») или «однонаправленным» («unidirectional») потоком данных. 
Состояние всегда принадлежит определённому компоненту, а любые производные этого состояния могут влиять только на компоненты, 
находящиеся «ниже» в дереве компонентов.


## Особенности API

### React key 

Ключи должны быть уникальными среди соседних элементов.
Ключи внутри массива должны быть уникальными только среди своих соседних элементов. 
Им не нужно быть уникальными глобально. Можно использовать один и тот же ключ в двух разных массивах.
Пример:

```jsx
function Blog(props) {
  const sidebar = (
    <ul>
      {props.posts.map((post) =>
        <li key={post.id}>
          {post.title}
        </li>
      )}
    </ul>
  );
  const content = props.posts.map((post) =>
    <div key={post.id}>
      <h3>{post.title}</h3>
      <p>{post.content}</p>
    </div>
  );
  return (
    <div>
      {sidebar}
      <hr />
      {content}
    </div>
  );
}

const posts = [
  {id: 1, title: 'Привет, мир', content: 'Добро пожаловать в документацию React!'},
  {id: 2, title: 'Установка', content: 'React можно установить из npm.'}
];
ReactDOM.render(
  <Blog posts={posts} />,
  document.getElementById('root')
);
```

### React.lazy

Функция React.lazy позволяет рендерить динамический импорт как обычный компонент. 
React.lazy принимает функцию, которая должна вызвать динамический import(). 
Результатом возвращённого Promise является модуль, который экспортирует **по умолчанию (export default)** React-компонент.

Компонент с ленивой загрузкой должен рендериться внутри компонента Suspense, который позволяет 
нам показать запасное содержимое (например, индикатор загрузки) пока происходит загрузка ленивого компонента.

Проп fallback принимает любой React-элемент, который вы хотите показать, пока происходит загрузка компонента. 
Компонент Suspense можно разместить в любом месте над ленивым компонентом. 
Кроме того, можно обернуть несколько ленивых компонентов одним компонентом Suspense.

```jsx
import React, { Suspense } from 'react/index';

const OtherComponent = React.lazy(() => import('./OtherComponent'));

function MyComponent() {
  return (
    <div>
      <Suspense fallback={<div>Загрузка...</div>}>
        <OtherComponent />
      </Suspense>
    </div>
  );
}
```

### React предохранители

Если какой-то модуль не загружается (например, из-за сбоя сети), это вызовет ошибку. 
Вы можете обрабатывать эти ошибки для улучшения пользовательского опыта с помощью Предохранителей. 
После создания предохранителя, его можно использовать в любом месте над ленивыми компонентами для отображения состояния ошибки.

Классовый компонент является предохранителем, 
если он включает хотя бы один из следующих методов жизненного цикла: static getDerivedStateFromError() или componentDidCatch().
Используйте static getDerivedStateFromError() при рендеринге запасного UI в случае отлова ошибки. 
Используйте componentDidCatch() при написании кода для журналирования информации об отловленной ошибке.
Обратите внимание, что предохранители отлавливают ошибки **исключительно в своих дочерних компонентах**.

Начиная с React 16, ошибки, не отловленные ни одним из предохранителей, 
будут приводить к размонтированию всего дерева компонентов React.

Код компонента ErrorBoundary можно посмотреть [здесь](../ready-solutions/index.md)

```jsx
import React, { Suspense } from 'react';
import ErrorBoundary  from './ErrorBoundary';

const OtherComponent = React.lazy(() => import('./OtherComponent'));
const AnotherComponent = React.lazy(() => import('./AnotherComponent'));

const MyComponent = () => (
  <div>
    <ErrorBoundary>
      <Suspense fallback={<div>Загрузка...</div>}>
        <section>
          <OtherComponent />
          <AnotherComponent />
        </section>
      </Suspense>
    </ErrorBoundary>
  </div>
);
```

### React Context.Provider

Все потребители, которые являются потомками Provider, будут повторно рендериться, как только проп value у Provider изменится. 
Потребитель (включая .contextType и useContext) перерендерится при изменении контекста, даже если его родитель, 
не использующий данный контекст, блокирует повторные рендеры с помощью shouldComponentUpdate.
