# Концепции и определения

## Рекурсия

#### Варианты определений

1. Это термин в программировании, означающий вызов функцией самой себя. Рекурсивные функции могут быть использованы для элегантного решения определённых задач.

2. Это приём программирования, полезный в ситуациях, когда задача может быть естественно разделена на несколько аналогичных, но более простых задач. Или когда задача может быть упрощена до несложных действий плюс простой вариант той же задачи. Или, как мы скоро увидим, для работы с определёнными структурами данных. В процессе выполнения задачи в теле функции могут быть вызваны другие функции для выполнения подзадач. Частный случай подвызова – когда функция вызывает сама себя. Это как раз и называется рекурсией.

#### Дополнительные определения

1. Общее количество вложенных вызовов (включая первый) называют глубиной рекурсии. В нашем случае она будет равна n.

2. Когда функция вызывает саму себя, это называется шагом рекурсии.

3. База рекурсии – это такие аргументы функции, которые делают задачу настолько простой, что решение не требует дальнейших вложенных вызовов.

4. Контекст выполнения – специальная внутренняя структура данных, которая содержит информацию о вызове функции. Она включает в себя конкретное место в коде, на котором находится интерпретатор, локальные переменные функции, значение this (мы не используем его в данном примере) и прочую служебную информацию. Один вызов функции имеет ровно один контекст выполнения, связанный с ним.

5. Рекурсивная (рекурсивно определяемая) структура данных – это структура, которая повторяет саму себя в своих частях (например, HTML- и XML-документы).

#### Особенности использования

1. **Любая рекурсия может быть переделана в цикл. Как правило, вариант с циклом будет эффективнее.**

2. Максимальная глубина рекурсии ограничена движком JavaScript. Точно можно рассчитывать на 10000 вложенных вызовов, некоторые интерпретаторы допускают и больше, но для большинства из них 100000 вызовов – за пределами возможностей. Существуют автоматические оптимизации, помогающие избежать переполнения стека вызовов («оптимизация хвостовой рекурсии»), но они ещё не поддерживаются везде и работают только для простых случаев. Это ограничивает применение рекурсии, но она всё равно широко распространена: для решения большого числа задач рекурсивный способ решения даёт более простой код, который легче поддерживать.

## Замыкание

#### Варианты определений

1. Это функция, которая запоминает свои внешние переменные и может получить к ним доступ. В JavaScript, все функции изначально являются замыканиями (есть только одно исключение с "new Function"). То есть функция автоматически запоминают, где были созданы, с помощью скрытого свойства `[[Environment]]`, и все они могут получить доступ к внешним переменным.

#### Дополнительные определения

1. Лексическое окружение – это специальный внутренний объект. Мы не можем получить его в нашем коде и изменять напрямую. Сам движок JavaScript может оптимизировать его, уничтожать неиспользуемые переменные для освобождения памяти и выполнять другие внутренние уловки.

#### Особенности использования

1. Пожалуйста, обратите внимание, что новое лексическое окружение функции создаётся каждый раз, когда функция выполняется. И, если функция вызывается несколько раз, то для каждого вызова будет своё лексическое окружение, со своими, специфичными для этого вызова, локальными переменными и параметрами.

2. Все функции «при рождении» получают скрытое свойство `[[Environment]]`, которое ссылается на лексическое окружение места, где они были созданы.

3. Как и все лексические окружения, оно содержит две вещи:

   - Environment Record с локальными переменными.
   - Ссылка на внешнее окружение, которая устанавливается в значение `[[Environment]]` функции. В данном случае, `[[Environment]]` функции makeCounter ссылается на глобальное лексическое окружение.

4. Функция всегда получает текущее (последнее) значения внешних переменных, которые есть на **момент исполнения этой функции**

## Декораторы

#### Варианты определений

1. Это обёртка вокруг функции, которая изменяет поведение последней. Основная работа по-прежнему выполняется функцией. Декораторы можно рассматривать как «дополнительные возможности» или «аспекты», которые можно добавить в функцию. Мы можем добавить один или несколько декораторов. И всё это без изменения кода оригинальной функции!
