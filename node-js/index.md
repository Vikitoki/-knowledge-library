# Node JS

Информация взята отсюда: <https://www.freecodecamp.org/news/the-definitive-node-js-handbook-6912378afc6e>
Перевод в формате пдф можно взять отсюда: <https://habr.com/ru/company/ruvds/blog/428576/>

## Менеджер версий

Популярным менеджером версий Node.js является [nvm](https://github.com/nvm-sh/nvm/blob/master/README.md). 
Это средство позволяет удобно переключаться
между различными версиями Node.js, с его помощью можно, например, установить и попробовать
новую версию Node.js, после чего, при необходимости, вернуться на старую. Nvm пригодится и в
ситуации, когда нужно испытать какой-нибудь код на старой версии Node.js.

---

## Программные способы выхода из приложения

1. Модуль ядра process предоставляет удобный метод, который позволяет осуществить программный
выход из Node.js-приложения. Выглядит это так:

    ```js
    process.exit(1)
    ```
    
    Когда Node.js встречает в коде такую команду, это приводит к тому, что его процесс мгновенно
    завершается. Это означает, что абсолютно всё, чем занималась программа, будет довольно грубо и
    безусловно прервано. Речь идёт о невызванных коллбэках, о выполняемых в момент выхода сетевых
    запросах, о действиях с файлами, об операциях записи в stdout или stderr.
    
    По умолчанию этот код имеет значение 0, что означает успешное завершение работы. Другие коды
    выхода имеют другие значения, которые могут оказаться полезными для использования их в
    собственной системе для того, чтобы наладить взаимодействие одних программ с другими.
    Подробности о кодах завершения работы программ можно почитать [здесь](https://nodejs.org/api/process.html#process_exit_codes).
    
    Код выхода, кроме того, можно назначить свойству process.exitCode. Выглядит это так:
    
    ```js
    process.exitCode = 1
    ```
    
    После того, как программа завершит работу, Node.js вернёт системе этот код.

2. Для завершения работы программ преимущественно нужно использовать сигнал SIGTERM и выполнить
   необходимые действия с помощью соответствующего обработчика. Сигналы — это средства взаимодействия процессов в стандарте. 
   Они представляют собой уведомления, отправляемые процессу для того, чтобы сообщить ему о неких событиях. Пример:

    ```js
    const express = require('express');
    const app = express()
   
    app.get('/', (req, res) => {
      res.send('Hi!')
    })
    app.listen(3000, () => console.log('Server ready'))
   
    process.on('SIGTERM', () => {
      app.close(() => {
        console.log('Process terminated')
      })
    })
    ```

    Например, сигнал SIGKILL сообщает процессу о том, что ему нужно немедленно завершить работу.
    Он, в идеале, работает так же, как process.exit(). Сигнал SIGTERM сообщает процессу о том, что ему нужно 
    осуществить процедуру нормального
    завершения работы. Подобные сигналы отправляются из менеджеров процессов, вроде upstart или
    supervisord, и из многих других.
    Отправить такой сигнал можно и из самой программы, воспользовавшись следующей командой:

    ```js
    process.kill(process.pid, 'SIGTERM')
    ```

---

## Чтение переменных окружения

Вот пример работы с переменной окружения NODE_ENV, которая, по умолчанию, установлена в
значение development:

```js
process.env.NODE_ENV // "development"
```

Если, до запуска скрипта, установить её в значение production, это сообщит Node.js о том, что
программа выполняется в продакшн-окружении. Подобным образом можно работать и с другими переменными среды, 
например, с теми, которые установлены вами самостоятельно.

## Режим REPL

Аббревиатура REPL расшифровывается как Read-Evaluate-Print-Loop (цикл «чтение — вычисление —
вывод»). Использование REPL — это отличный способ быстрого исследования возможностей Node.js.

Если команду `node`, но не указывать имя файла, Node.js будет запущен в режиме REPL. 
Если вы попробуете сейчас ввести такую команду в своём терминале, то в результате увидите
примерно следующее:

```
> node
>
```

Node.js теперь находится в режиме ожидания. Система ждёт, что мы введём в командной строке
какой-нибудь JavaScript-код, который она будет выполнять. Сам режим полезен для того, чтобы просматривать
методы глобального API для Node JS. Введите в командную строку имя какого-нибудь стандартного объекта JavaScript, 
например — Number, добавьте после него точку и нажмите клавишу Tab. 
REPL выведет список свойств и методов объекта, с которыми может взаимодействовать разработчик.
Для того чтобы узнать, с какими глобальными объектами Node.js вы можете работать, введите в
терминале команду global. и нажмите Tab.

---

## npm, файлы package.json и package-lock.json

### Обновление пакетов

Для обновления пакетов служит следующая команда:

```
npm update
```

Получив эту команду, npm проверит все пакеты на наличие их новых версий, и, если найдёт их новые
версии, соответствующие ограничениям на версии пакетов, заданным в package.json, установит их.
Обновить можно и отдельный пакет:

```
npm update <package-name>
```

### Глобальная установка пакетов

Глобальная установка пакетов выполняется с использованием флага -g:

```
npm install -g lodash
```

Выполняя такую команду, npm не устанавливает пакет в локальную папку проекта. Вместо этого он
копирует файлы пакета в некое глобальное расположение. Куда именно попадают эти файлы?
Для того чтобы это узнать, воспользуйтесь следующей командой:

```
npm root -g
```

### Использование npx

Итак, после установки пакета с использованием команды npm install cowsay, он, вместе со своими
зависимостями, попадёт в node_modules. А в скрытую папку .bin будут записаны символические
ссылки на бинарные файлы cowsay (пакет представляет собой исполняемый файлы). Как их выполнять?

Конечно, можно, для вызова программы, ввести в терминале нечто вроде
`./node_modules/.bin/cowsay`. Это рабочий подход, но гораздо лучше воспользоваться npx,
средством для запуска исполняемых файлов npm-пакетов, включаемым в npm начиная с версии 5.2. А
именно, в нашем случае понадобится такая команда:

```
npx cowsay
```

Путь к пакету npx найдёт автоматически. 
В npx имеется ещё одна интереснейшая возможность, благодаря которой утилиты можно запускать без
их предварительной установки.

### О версиях пакетов и семантическом версионировании

Учитывая то, что при использовании семантического версионирования все номера версий пакетов
состоят из последовательностей, представляющих собой три числа, о смысле которых мы говорили
выше, опишем следующие правила использования спецификаторов версий:

- ~: если вы задаёте версию в виде ~0.13.0 это означает, что вас интересуют лишь патч-релизы
пакета. То есть, пакет 0.13.1 вам подойдёт, а 0.14.0 — нет.
- ^: если номер версии задан в виде ^0.13.0, это означает, что вам подходят новые патч-версии
и минорные версии пакета. То есть, вас устроят версии пакета 0.13.1, 0.14.0, и так далее.
- *: воспользовавшись этим символом, вы сообщаете системе, что вас устроят любые свежие
версии пакета, в том числе — его новые мажорные релизы.
- \>: подходят любые версии пакета, которые больше заданной.
- \>=: подходят любые версии пакета, которые равны или больше заданной.
- <=: вас устроят пакеты, версии которых равны заданной или меньше её.
- <: вас интересуют пакеты, версии которых меньше заданной.
- =: вам нужна только заданная версия пакета.
- -: используется для указания диапазона подходящих версий, например — 2.1.0 - 2.6.2.
- ||: позволяет комбинировать наборы условий, касающихся пакетов. Например, это может
выглядеть как < 2.1 || > 2.6.

Есть и ещё некоторые правила:

- отсутствие дополнительных символов: если используется номер версии пакета без
дополнительных символов, это значит, что вашему пакету нужна только заданная версия
пакета-зависимости и никакая другая.
- latest: указывает на то, что вам требуется самая свежая версия некоего пакета

Большинство вышеописанных спецификаторов можно комбинировать, например, задавая диапазоны
подходящих версий пакетов-зависимостей. Скажем, конструкция вида `1.0.0 || >=1.1.0 <1.2.0`
указывает на то, что планируется использовать либо версию пакета 1.0.0, либо версию, номер
которой больше или равен 1.1.0, но меньше 1.2.0.

### Выяснение версий установленных npm-пакетов

1. Для того чтобы узнать версии всех установленных в папке проекта npm-пакетов, включая их
зависимости, выполните следующую команду:

    ```
    npm list
    ```

2. Для того чтобы получить подобный список пакетов, установленных глобально, можно воспользоваться
следующей командой:

    ```
    npm list -g
    ```

3. Вывести только сведения о локальных пакетах верхнего уровня (то есть, тех, которые вы
   устанавливали самостоятельно и которые перечислены в package.json) можно так:

    ```
    npm list --depth=0
    ```
   
4. Если вы хотите узнать о том, каков номер самой свежей версии некоего пакета, доступного в
   npm-репозитории, вам понадобится команда следующего вида:

    ```
    npm view <package> version
    ```

    В ответ она выдаёт номер версии пакета

5. Установить нужную версию пакета из npm можно, воспользовавшись следующей конструкцией:

    ```
    npm install <package>@<version>
    ```


### Обновление зависимостей проекта до их самых свежих версий

1. Если, например, выходит новая минорная версия пакета и мы выполняем команду `npm update`, то
обновляется установленная версия пакета и при этом сведения об установленном пакете обновляются
в файле package-lock.json, а файл package.json остаётся неизменным.
Для того чтобы узнать, вышли ли новые версии используемых в проекте пакетов, можно
воспользоваться следующей командой:

    ```
    npm outdated
    ```

2. Некоторые из доступных обновлений пакетов представляют собой их мажорные релизы, обновления до
   которых не произойдёт при выполнении команды npm update. Обновление до мажорных релизов этой
   командой не производится, так как они (по определению) могут содержать серьёзные изменения, не
   отличающиеся обратной совместимостью с предыдущими мажорными релизами, а npm стремится
   избавить разработчика от проблем, которые может вызвать использование подобных пакетов.
   Для того чтобы обновиться до новых мажорных версий всех используемых пакетов, глобально
   установите пакет `npm-check-updates`, а затем запустить утилиту, предоставляемую им:

    ```
    npm install -g npm-check-updates
    ncu -u
    ```

    Эта команда обновит файл package.json, внеся изменения в указания о подходящих версиях
    пакетов в разделы dependencies и devDependencies. Это позволит npm обновить пакеты,
    используемые в проекте, до новых мажорных версий после запуска команды npm update.

### Локальная или глобальная деинсталляция пакетов

Для того чтобы деинсталлировать пакет, ранее установленный локально, выполните команду следующего вида:

```
npm uninstall <package-name>
```

Если пакет установлен глобально, то для его удаления нужно будет воспользоваться флагом -g
(--global). Например, подобная команда может выглядеть так:

```
npm uninstall -g webpack
```

---

## Цикл событий

### Работа со временем

В Node.js функции для работы с таймерами входят в модуль timer, но пользоваться ими можно, не подключая этот модуль в коде, так
как они являются глобальными.


1. process.nextTick()

   Метод process.nextTick() по-особому взаимодействует с циклом событий. Тиком (tick) называют
   один полный проход цикла событий. Передавая функцию методу process.nextTick(), мы сообщаем
   системе о том, что эту функцию нужно вызвать после завершения текущей итерации цикла событий, до
   начала следующей. 

    ```js
    process.nextTick(() => {
      // выполнить какие-то действия
    })
    ```

    Предположим, цикл событий занят выполнением кода текущей функции. Когда эта операция
    завершается, JavaScript-движок выполнит все функции, переданные `process.nextTick()` в ходе
    выполнения предыдущей операции. Используя этот механизм, мы стремимся к тому, чтобы некая
    функция была бы выполнена асинхронно (после текущей функции), но как можно скорее, без
    постановки её в очередь.
    
    Например, если воспользоваться конструкцией `setTimeout(() => {}, 0)` функция будет
    выполнена на следующей итерации цикла событий, то есть — гораздо позже, чем при использовании в
    такой же ситуации `process.nextTick()`. Этот метод стоит использовать тогда, когда нужно
    обеспечить выполнение некоего кода в самом начале следующей итерации цикла событий.

2. setImmediate()

    Ещё одной функцией, предоставляемой Node.js для асинхронного выполнения кода, является
    setImmediate(). Вот как ей пользоваться:
    
    ```
    setImmediate(() => {
      // выполнить некий код
    })
    ```

   Функция обратного вызова, переданная setImmediate(), будет выполнена на следующей итерации
   цикла событий.

    Вызов функции setTimeout() с установленной задержкой в 0 мс очень похож на вызов
    setImmediate(). Порядок выполнения функций, переданных им, зависит от различных факторов, но
    и в том и в другом случаях коллбэки будут вызваны на следующей итерации цикла событий.

3. setTimeout()

    Функция setTimeout() принимает коллбэк и время, в миллисекундах, по
    прошествии которого будет вызван коллбэк. Пример:

    ```
    setTimeout(() => {
      // выполняется через 2 секунды
    }, 2000)
    ```

    В результате работы функции возвращается идентификатор таймера. Обычно он не используется, но его
    можно сохранить, и, при необходимости, удалить таймер, если в запланированном выполнении
    коллбэка больше нет необходимости:

    ```js
    const id = setTimeout(() => {
      // этот код должен выполниться через 2 секунды
    }, 2000)
    
    // Программист передумал, выполнять этот код больше не нужно
    clearTimeout(id)
    ```
