# Особенности инструмента

## Дизайн-решения

Typescript базируется на 4 вещах:

1. **Структурная типизация**. Условно у нас есть две сущности, которые одинаково летают, одинаково крякают, но при этом они порождены
   от разных сущностей. В мире JavaScript очень много библиотек, которые имеют похожие системы типов. Поэтому, было бы очень плохо
   если бы между собой они порождали конфликты.
   Компилятор Typescript считает типы совместимыми, если сопоставляемый тип имеет все признаки типа, с которым сопоставляется.
   Пример:

```ts
class USD {
  constructor(public amount: number) {}
}

class EUR {
  constructor(public amount: number) {}
}

const walletFirst: USD = new USD(100);
const walletSecond: EUR = walletFirst;
```

2. **Aliasing (передача по ссылке)**. Пример:

```ts
type Version = {
  value: number;
};

type RelaxedVersion = {
  value: number | string;
};

const versionFirst: Version = {
  value: 1,
};

const versionSecond: RelaxedVersion = versionFirst;
versionSecond.value = "something";

versionFirst.value.toFixed(2);
```

Данный код позволит уронить программу во время выполнения. Думаю, что здесь должно быть понятно - это дизайн решение было взято примяком
из JavaScript. В данном случае, Typescript никак не мешает нам делать то, что задумано разработчиком. Вместо строгой проверки сущностей
на предмет более широкого типа, Typescript в строке `const versionSecond: RelaxedVersion = versionFirst` доверяет нам, что мы не обманули его
и в переменной всегда будет лежать множество значений указанного типа.

3. **Мутабельность**. В JavaScript очень много вещей, которые поддаются мутациям. Как самый явный пример - это не примитивы,
   которые передаются по ссылке, а как более интересный пример - DOM дерево. Typescript пошёл по пути поддержки такого подхода.
   Здесь встаёт вопрос: можем ли мы сделать что-то, для повышения надёжности нашего кода с точки зрения типов Typescript.
   Ответ прост - да можем, при помощи применения концепций парадигмы функционального программирования.

4. **Иерархия типов**. Прекрасные материалы про соотношения типов между собой:

- <https://habr.com/ru/post/477448/>
- <https://habr.com/ru/post/531030/>

## Хамелеонные конструкции Typescript

Существуют конструкции, которые имеют разное значение в зависимости
от того в каком пространстве они находятся (типов или значений):

1. Оператор typeof

```ts
const p = { first: "Jane", last: "Jacobs" };

type T1 = typeof p; // Тип Person
type T2 = typeof email;
// Тип (p: Person, субъект: string, тело: string) => Response

const v1 = typeof p; // значение object
const v2 = typeof email; // значение function
```

2. Методы доступа к свойствам по ключу:

```ts
const p = { first: "Jane", last: "Jacobs" };

const first: Person["first"] = p["first"]; // значение Jane

type PersonEl = Person["first" | "last"]; // Тип string
type Tuple = [string, number, Date];
type TupleEl = Tuple[number]; // Тип string | number | Date
```

3. Метод this в пространстве значений является ключевым словом
   JavaScript (правило 49). В пространстве типов this выступает как
   TypeScript-тип this (а-ля «полиморфный this»). Он полезен при выполнении цепочек методов для подклассов.

```ts
const elNull = document.getElementById("foo"); // Тип HTMLElement | null
const el = document.getElementById("foo")!; // Тип HTMLElement
```

4. В качестве префикса ! выступает как оператор единичного отрицания
   в JavaScript (а-ля «не»). Будучи суффиксом, он означает ненулевое утверждение типа.

5. В пространстве значений & и | являются побитовыми операциями «и»
   и «или». В пространстве типов они выступают как операторы объединения и пересечения.

6. Ключевое слово const вводит новую переменную, но as const изменяет
   выведенный тип на постоянный.

7. extends может либо определять подкласс (класс А расширяет класс B)
   или подтип (интерфейс A расширяет интерфейс B), либо ставить ограничение на обобщенный тип (Generic<T extends number>).

8. in может являться либо частью цикла for…in, либо отображаемым типом.

## Type vs Interface

Граница между этими вариантами с течением времени размылась настолько,
что в некоторых ситуациях можно использовать и то и другое.
Однако есть небольшие или существенные различия:

1. Определение типов функции.

```ts
type TFn = (x: number) => string;
interface IFn {
  (x: number): string;
}
```

Псевдоним типа выглядит более естественно для этого простейшего типа
функции.

2. Interface может расширять Type и наоборот.

```ts
interface IStateWithPop extends TState {
  population: number;
}

type TStateWithPop = IState & { population: number };
```

Оговорка заключается в том, что
Interface не может расширять сложные типы вроде типов объединений.
Если вам нужно именно это, придется использовать Type и &.

3. Cуществуют типы объединения, но не существует интерфейсов объединения.

```ts
type AorB = "a" | "b";
```

В целом Type имеет больше возможностей, чем Interface.
Он может выступать в качестве объединения, а также пользоваться более продвинутыми возможностями вроде
отображения или условных типов.

4. Помимо этого, с помощью Type можно ясно выразить кортежи и типы массивов.

```ts
type Pair = [number, number];
type StringList = string[];
type NamedNums = [string, ...number[]];
```

Тем не менее у interface есть некоторые возможности, отсутствующие у type.

5. Interface может быть дополнен.

```ts
interface IState {
  name: string;
  capital: string;
}

interface IState {
  population: number;
}

const wyoming: IState = {
  name: "Wyoming",
  capital: "Cheyenne",
  population: 500_000,
}; // ok
```

Это называется объединением деклараций. Главным образом оно используется с файлами деклараций типов.
Для их поддержки уместно использовать interface, поскольку в декларациях типов могут быть пропуски,
которые должны заполнять пользователи. TypeScript использует слияние, чтобы получать разные типы для разных
версий стандартной библиотеки JavaScript.

**Выводы**:

Вернемся к вопросу выбора между type и interface. Для сложных типов
выбора нет: необходимо использовать псевдоним типа. Но что насчет
более простых типов объектов, которые могут быть представлены и другим
путем? Чтобы ответить на этот вопрос, следует учитывать согласованность и возможное дополнение.
Если вы работаете с кодом, который постоянно использует interface, то придерживайтесь interface. Если же
в нем применяется type, используйте type.

В проектах, не имеющих установленного стиля, вам следует поразмыслить
над возможностью дополнения. Если вы опубликуете декларации типов для
API, пользователям будет удобно вставлять новые поля через interface при
изменении API. Однако для типа, который используется внутри проекта,
слияние деклараций может оказаться ошибкой, поэтому отдайте предпочтение type.
