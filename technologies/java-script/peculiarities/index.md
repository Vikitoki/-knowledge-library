# Особенности

## Браузерное окружение

- prompt. Показывает сообщение и запрашивает ввод текста от пользователя. Возвращает напечатанный в поле ввода текст или null, если была нажата кнопка «Отмена» или Esc с клавиатуры. Лучше всего всегда устанавливать значение по умолчанию!

  ```js
  let test = prompt("Test", "");
  ```

- confirm. показывает сообщение и ждёт, пока пользователь нажмёт OK или Отмена. Возвращает true, если нажата OK, и false, если нажата кнопка «Отмена» или Esc с клавиатуры.

## Операторы

- Нулевое слияния и "логическое или". Важное различие между ними заключается в том, что:

  ```
  || - возвращает первое истинное значение.
  ?? - возвращает первое определённое значение.
  ```

- По соображениям безопасности JavaScript запрещает использование оператора ?? вместе с && и ||, если приоритет явно не указан при помощи круглых скобок.

  ```js
  let x = 1 && 2 ?? 3; // Синтаксическая ошибка
  ```

## Числа

- Обычные числа в JavaScript хранятся в 64-битном формате IEEE-754, который также называют «числа с плавающей точкой двойной точности» (double precision floating point numbers). Это числа, которые мы будем использовать чаще всего. Мы поговорим о них в этой главе.

- Числовой формат IEEE-754 решает проблему манипуляции с дробными числами путём округления до ближайшего возможного числа. Правила округления обычно не позволяют нам увидеть эту «крошечную потерю точности», но она ВСЕГДА существует.

- Функция parseInt() имеет необязательный второй параметр. Он определяет систему счисления, таким образом parseInt может также читать строки с шестнадцатеричными числами, двоичными числами и т.д.:

  ```js
  alert(parseInt("0xff", 16)); // 255
  alert(parseInt("ff", 16)); // 255, без 0x тоже работает

  alert(parseInt("2n9c", 36)); // 123456
  ```

- Math.random()
  Возвращает псевдослучайное число в диапазоне от 0 (включительно) до 1 (но не включая 1). Поэтому, не стоит забывать, что число 0 - это тоже возможный вариант событий!

- Методы Math.round и toFixed, согласно документации, округляют до ближайшего целого числа: 0..4 округляется в меньшую сторону, тогда как 5..9 в большую сторону.

  ```js
  alert((1.35).toFixed(1)); // 1.4
  alert((6.35).toFixed(1)); // 6.3
  ```

  _Вопрос_: что произошло с 6.35?
  _Ответ_: Во внутреннем двоичном представлении 6.35 является бесконечной двоичной дробью. Хранится она с потерей точности:

  ```js
  alert((6.35).toFixed(20)); // 6.34999999999999964473
  alert((1.35).toFixed(20)); // 1.35000000000000008882
  ```

  Потеря точности может как увеличивать, так и уменьшать число. В случае c 6.35 число становится чуть меньше, поэтому оно округляется в меньшую сторону. Каким образом можно исправить ошибку в округлении числа 6.35? Написать собственную функцию для точного округления чисел:

  ```js
  function exactRound(number) {
    Math.round(number * 10) / 10;
  }

  exactRound(6.35); // 6.35 -> 63.5 -> 64(rounded) -> 6.4
  ```

  Обратите внимание, что для числа 63.5 не происходит потери точности. Дело в том, что десятичная часть 0.5 на самом деле 1/2. Дробные числа, делённые на степень 2, точно представлены в двоичной системе, теперь мы можем округлить число.

## Массивы

- Array.sort(fn)

  Он возвращает отсортированный массив, но обычно возвращаемое значение игнорируется, так как изменяется сам arr. _По умолчанию элементы сортируются как строки._

  Чтобы использовать наш собственный порядок сортировки, нам нужно предоставить функцию в качестве аргумента arr.sort().

  ```js
  function compareNumeric(a, b) {
    if (a > b) return 1;
    if (a == b) return 0;
    if (a < b) return -1;
  }

  let arr = [2, 1, 15];

  arr.sort(compareNumeric);

  alert(arr); // 1, 2, 15
  ```

  Метод arr.sort(fn) реализует общий алгоритм сортировки. Нам не нужно заботиться о том, как он работает внутри (в большинстве случаев это оптимизированная быстрая сортировка или Timsort). Она проходится по массиву, сравнивает его элементы с помощью предоставленной функции и переупорядочивает их. Всё, что остаётся нам, это предоставить fn, которая делает это сравнение. На самом деле от функции сравнения требуется любое положительное число, чтобы сказать «больше», и отрицательное число, чтобы сказать «меньше». Это позволяет писать более короткие функции:

  ```js
  let arr = [2, 1, 15];

  arr.sort((a, b)  => a - b;
  );

  alert(arr); // 1, 2, 15
  ```

  Кстати, если мы когда-нибудь захотим узнать, какие элементы сравниваются – ничто не мешает нам вывести их на экран:

  ```js
  [1, -2, 15, 2, 0, 8].sort(function (a, b) {
    alert(a + " <> " + b);
    return a - b;
  });
  ```

- Обратите внимание, что методы sort, reverse и splice изменяют исходный массив.

## Map и Set

1. Map – коллекция пар ключ-значение. Отличия от обычного объекта Object:

   - Что угодно может быть ключом, в том числе и объекты.
   - Есть дополнительные методы, свойство size.

2. Set – коллекция уникальных значений, так называемое «множество».

## WeakMap и WeakSet

WeakSet – это Set-подобная коллекция, которая хранит только объекты и удаляет их, как только они становятся недостижимыми иными путями.

Обе этих структуры данных не поддерживают методы и свойства, работающие со всем содержимым сразу или возвращающие информацию о размере коллекции. Возможны только операции на отдельном элементе коллекции.

WeakMap и WeakSet используются как вспомогательные структуры данных в дополнение к «основному» месту хранения объекта. Если объект удаляется из основного хранилища и нигде не используется, кроме как в качестве ключа в WeakMap или в WeakSet, то он будет удалён автоматически.

## Дата и время

1. new Date() <br>

   Без аргументов – создаёт объект Date с текущими датой и временем:

   ```js
   let now = new Date();
   alert(now); // показывает текущие дату и время
   ```

2. new Date(number) <br>

   Создаёт объект Date с временем, равным количеству миллисекунд (тысячная доля секунды), прошедших с 1 января 1970 года.

   ```js
   // UTC+0 - это лондонское время без перехода на летнее время.

   // 0 соответствует 01.01.1970 UTC+0
   let Jan01_1970 = new Date(0);

   // теперь добавим 24 часа и получим 02.01.1970 UTC+0
   let Jan02_1970 = new Date(24 * 3600 * 1000);
   alert(Jan02_1970);

   // теперь отнимем 24 часа и получим 31.12.1969 UTC+0
   let Dec31_1969 = new Date(-24 * 3600 * 1000);
   alert(Dec31_1969);
   ```

3. new Date(string) <br>

   Если аргумент всего один, и это строка, то из неё «прочитывается» дата. Алгоритм разбора – такой же, как в Date.parse, который мы рассмотрим позже.

   ```js
   let date = new Date("2017-01-26");
   alert(date);
   ```

4. Date.now()

Если нужно просто измерить время, объект Date нам не нужен. Этот особый метод возвращает текущую метку времени. Семантически он эквивалентен new Date().getTime(), однако метод не создаёт промежуточный объект Date. Так что этот способ работает быстрее и не нагружает сборщик мусора.

Данный метод используется из соображений удобства или когда важно быстродействие, например, при разработке игр на JavaScript или других специализированных приложений.

5. Существуют методы получения года, месяца и т.д. из объекта Date. Подробнее о них можно почитать в документации. Самое важное - **все вышеперечисленные варианты возвращают значения в соответствии с местным часовым поясом.** Однако существуют и их UTC-варианты, возвращающие день, месяц, год для временной зоны UTC+0: _getUTCFullYear(), getUTCMonth(), getUTCDay()_.

6. Помимо вышеприведённых методов, существуют два особых метода без UTC-варианта:

   - _getTime()_. Для заданной даты возвращает таймстамп – количество миллисекунд, прошедших с 1 января 1970 года UTC+0.

   - _getTimezoneOffset()_. Возвращает разницу в минутах между UTC и местным часовым поясом:

## Декораторы

Декоратор – это обёртка вокруг функции, которая изменяет поведение последней. Основная работа по-прежнему выполняется функцией. Декораторы можно рассматривать как «дополнительные возможности» или «аспекты», которые можно добавить в функцию. Мы можем добавить один или несколько декораторов. И всё это без изменения кода оригинальной функции!

## Прототипное наследование

1. Типичный случай прототипирования

```js
let animal = {
  eats: true,
  walk() {
    alert("Animal walk");
  },
};

let rabbit = {
  jumps: true,
  __proto__: animal,
};

// walk взят из прототипа
rabbit.walk();
```

2. Значение «this»

**Неважно, где находится метод: в объекте или его прототипе. При вызове метода this — всегда объект перед точкой.**

```js
// методы animal
let animal = {
  walk() {
    if (!this.isSleeping) {
      alert(`I walk`);
    }
  },
  sleep() {
    this.isSleeping = true;
  },
};

let rabbit = {
  name: "White Rabbit",
  __proto__: animal,
};

// модифицирует rabbit.isSleeping
rabbit.sleep();

alert(rabbit.isSleeping); // true
alert(animal.isSleeping); // undefined (нет такого свойства в прототипе)
```

В результате методы являются общими, а состояние объекта — нет!

3. F.prototype

- Если в F.prototype содержится объект, оператор new устанавливает его в качестве `[[Prototype]]` для нового объекта. Установка `Rabbit.prototype = animal` буквально говорит интерпретатору следующее: "При создании объекта через `new Rabbit()` запиши ему animal в `[[Prototype]]`".

```js
let animal = {
  eats: true,
};

function Rabbit(name) {
  this.name = name;
}

Rabbit.prototype = animal;

let rabbit = new Rabbit("White Rabbit"); //  rabbit.__proto__ == animal

alert(rabbit.eats); // true
```

- У каждой функции по умолчанию уже есть свойство "prototype". По умолчанию, оно представляет из себя объект с единственным свойством constructor, которое ссылается на функцию-конструктор.

```js
function Rabbit() {}
// по умолчанию:
// Rabbit.prototype = { constructor: Rabbit }

alert(Rabbit.prototype.constructor == Rabbit); // true
```

- В обычных объектах prototype не является чем-то особенным

```js
let user = {
  name: "John",
  prototype: "Bla-bla", // никакой магии нет - обычное свойство
};
```

4. Дополнения

- Свойство `__proto__` немного устарело, оно существует по историческим причинам. Современный JavaScript предполагает, что мы должны использовать функции `Object.getPrototypeOf` и `Object.setPrototypeOf` вместо того, чтобы получать/устанавливать прототип. Мы также рассмотрим эти функции позже.

- `__proto__` — не то же самое, что внутреннее свойство `[[Prototype]]`. Это геттер/сеттер для `[[Prototype]]`.

- Прототип используется только если свойство не найдено в первичном объекте

```js
let animal = {
  eats: true,
  walk() {
    /* этот метод не будет использоваться в rabbit */
  },
};

let rabbit = {
  __proto__: animal,
};

rabbit.walk = function () {
  alert("Rabbit! Bounce-bounce!");
};

rabbit.walk(); // Rabbit! Bounce-bounce!
```

- Свойства и методы `Object.prototype` **не перечислимы** из-за того, что у прототипа внутренний флаг `enumerable` стоит `false`.
