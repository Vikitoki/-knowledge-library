# Особенности JSX

## JSX - это тоже выражение

После компиляции каждое JSX-выражение становится обычным вызовом JavaScript-функции, результат которого — объект JavaScript.
Из этого следует, что JSX можно использовать внутри инструкций if и циклов for, присваивать переменным, передавать функции в качестве аргумента и возвращать из функции.

```jsx
function getGreeting(user) {
  if (user) {
    return <h1>Здравствуй, {formatName(user)}!</h1>;
  }
  return <h1>Здравствуй, незнакомец.</h1>;
}
```

## JSX предотвращает атаки, основанные на инъекции кода

```jsx
const title = response.potentiallyMaliciousInput;
// Этот код безопасен:
const element = <h1>{title}</h1>;
```

По умолчанию React DOM экранирует все значения, включённые в JSX перед тем как отрендерить их.
Это гарантирует, что вы никогда не внедрите чего-либо, что не было явно написано в вашем приложении.
Всё преобразуется в строчки, перед тем как быть отрендеренным.
Это помогает предотвращать атаки межсайтовым скриптингом (XSS).

## Использование записи через точку

Вы также можете ссылаться на React-компонент, используя запись через точку.
Это удобно, если у вас есть модуль, который экспортирует много React-компонентов.
К примеру, если `MyComponents.DatePicker` является компонентом, то вы можете обратиться к нему напрямую,
используя запись через точку:

```jsx
import React from "react";

const MyComponents = {
  DatePicker: function DatePicker(props) {
    return (
      <div>Представьте, что здесь цвет {props.color} виджета выбора даты.</div>
    );
  },
};

function BlueDatePicker() {
  return <MyComponents.DatePicker color="blue" />;
}
```

## Логические значения, null и undefined игнорируются

Значения `false`, `null`, `undefined` и `true` — валидные дочерние компоненты. Просто они не рендерятся.

Есть один нюанс в том, что React будет рендерить «ложные» (falsy) значения, такие как число 0.
Код ниже ведёт себя не так, как вы могли ожидать, так как 0 будет отображён, если массив props.messages пуст:

```jsx
<div>{props.messages.length && <MessageList messages={props.messages} />}</div>
```

Чтобы исправить это, убедитесь что выражение перед оператором && всегда является boolean:

```jsx
<div>
  {props.messages.length > 0 && <MessageList messages={props.messages} />}
</div>
```

И наоборот, если вы хотите, чтобы такие значения как `false`, `null`, `undefined` и `true` отрисовались,
то сначала вы должны преобразовать их в строку:

```jsx
<div>Моя переменная JavaScript - {String(myVariable)}.</div>
```
